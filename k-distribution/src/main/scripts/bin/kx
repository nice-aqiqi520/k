#!/bin/bash
set -e

export PATH="$(dirname "$0"):$PATH"

ARGV=()
bound=
depth=
color=false
if [ -t 1 ]; then
  color=true
fi
params=()
allPath=true
dir=.
cmd=
cmdprefix=
io=true
filterSubst=true
outputFile=-
pattern=
search=false
term=false
verbose=false
literal=false
outputMode=pretty
flags=

tempFiles=()
trap 'rm -rf ${tempFiles[*]}' INT TERM EXIT

input_file="$(mktemp tmp.in.XXXXXXXXXX)"
kore_output="$(mktemp tmp.out.XXXXXXXXXX)"
tempFiles+=("$input_file")
tempFiles+=("$kore_output")

execute () {
  (
  if $verbose; then
    set -x
  fi
  "$@"
  )
}

while [[ $# -gt 0 ]]
do
  arg="$1"
  if $literal; then
    ARGV+=("$1")
  else
    case "$arg" in
      --bound)
      bound="$2"
      shift
      ;;
  
      --depth)
      depth="$2"
      shift
      ;;
  
      --color)
      case "$2" in
        on)
        color=true
        ;;
  
        off)
        color=false
        ;;
  
        *)
        error 'Invalid value for --color. Should be "on" or "off".'
        ;;
      esac
      shift
      ;;
  
      -p*=*)
      keyval=${1#-p}
      key=${keyval%%=*}
      val=${keyval#*=}
      var_name="parser_$key"
      printf -v "$var_name" %s "$val"
      ;;
  
      -c*=*)
      keyval=${1#-c}
      key=${keyval%%=*}
      val=${keyval#*=}
      var_name="config_var_$key"
      params+=("$key")
      tempFile="$(mktemp tmp."$key".pretty.XXXXXXXXXX)"
      tempFiles+=("$tempFile")
      printf %s "$val" > "$tempFile"
      printf -v "$var_name" %s "$tempFile"
      ;;
  
      --default-claim-type)
      case "$2" in
        all-path)
        allPath=true
        ;;
  
        one-path)
        allPath=false
        ;;
  
        *)
        error 'Invalid value for --default-claim-type. Should be "all-path" or "one-path".'
        ;;
      esac
      shift
      ;;
  
      -d|--directory)
      dir="$2"
      shift
      ;;
  
      --dry-run)
      cmdprefix="echo "
      tempFiles=(${tempFiles[@]/$input_file})
      outputMode=none
      ;;
  
      --haskell-backend-command)
      cmd="$2"
      shift
      ;;
  
      -h|--help)
      print_usage
      exit 0
      ;;
  
      --io)
      case "$2" in
        on)
        io=true
        ;;
  
        off)
        io=false
        ;;
  
        *)
        error 'Invalid value for --io. Should be "on" or "off".'
        ;;
      esac
      shift
      ;;
  
      --no-substitution-filtering)
      filterSubst=false
      ;;
  
      -o|--output)
      case "$2" in
        pretty) ;;
        program) ;;
        kast) ;;
        binary) ;;
        json) ;;
        latex) ;;
        kore) ;;
        none) ;;
        *)
          error 'Invalid value for --output. Should be one of "pretty", "program", "kast", "binary", "json", "latex", "kore", or "none".'
  	;;
      esac
      outputMode="$2"
      shift
      ;;
  
      --output-file)
      outputFile="$2"
      shift
      ;;
  
      --parser)
      var_name="parser_PGM"
      printf -v "$var_name" %s "$2"
      shift
      ;;
  
      --pattern)
      pattern="$2"
      shift
      ;;
  
      --search)
      search=true
      searchType='!'
      ;;
  
      --search-all)
      search=true
      searchType='*'
      ;;
  
      --search-final)
      search=true
      searchType='!'
      ;;
  
      --search-one-or-more-steps)
      search=true
      searchType='+'
      ;;
  
      --search-one-step)
      search=true
      searchType='1'
      ;;
  
      --term)
      term=true
      ;;    
  
      -v|--verbose)
      verbose=true
      flags="$flags -v"
      ;;
  
      -save-temps)
      trap - INT TERM EXIT
      flags="$flags -save-temps"
      ;;
  
      --version)
      kompile --version
      exit 0
      ;;
  
      --debugger)
      cmdprefix="gdb --args "
      ;;
  
      --statistics)
      flags="$flags --statistics"
      ;;
  
      --)
      literal=true
      ;;
  
      -*)
      print_usage
      exit 1
      ;;
  
      *)
      ARGV+=("$1")
      ;;
    esac
  fi
  shift
done

if $search; then
  io=false
fi

if [[ "${#ARGV[@]}" -gt 1 ]]; then
  error 'Cannot pass more than one configuration variable as a positional argument.'
fi

kompiledDir=
hasKompiledDir=false
for file in "$dir"/*-kompiled; do
  kompiledDir=$file
  if $hasKompiledDir; then
    error 'Multiple compiled definitions found in the current working directory: ' "$dir"/*-kompiled
  fi
  hasKompiledDir=true
done

if ! $hasKompiledDir; then
  error 'Could not find a compiled definition. Use --directory to specify one.'
fi

hasArgv=false
if [[ "${#ARGV[@]}" -gt 0 ]]; then
  config_var_PGM="${ARGV[0]}"
  hasArgv=true
  params+=("PGM")
fi

mainModuleName=$(cat "$kompiledDir"/mainModule.txt)

if [ "$outputFile" = "-" ]; then
  outputFile=/dev/stdout
fi

if $term; then
  if [ -z "$parser_PGM" ]; then
    execute kast -m "$mainModuleName" "$config_var_PGM" -o kore > "$input_file"
  else
    execute $parser_PGM "$config_var_PGM" > "$input_file"
  fi
else
  for name in "${params[@]}"; do
    parser_name="parser_$name"
    config_name="config_var_$name"
    tempFile="$(mktemp tmp.in."$name".XXXXXXXXXX)"
    tempFiles+=("$tempFile")
    sortName=`cat "$kompiledDir"/sort_"$name".txt`
    if [ -z "${!parser_name}" ]; then
      if [ -f "$kompiledDir/parser_$name" ]; then
        parser="$kompiledDir/parser_$name"
      elif [ "$name" = "PGM" ]; then
        if $hasArgv; then
          parser="kast -o kore"
	else
          parser="kast -m $mainModuleName -o kore"
	fi
      else
        parser="kast -m $mainModuleName -o kore"
      fi
    else
      parser="${!parser_name}"
    fi
    execute $parser "${!config_name}" > "$tempFile"
    configVars="$configVars -c $name $tempFile $sortName korefile"
  done
  if [ "$(cat "$kompiledDir"/sort_IO.txt)" = "String" ]; then
    if $io; then
      ioText=on
    else
      ioText=off
    fi
    configVars="$configVars -c IO \dv{SortString{}}(\"$ioText\") String kore"
  fi
  if [ "$(cat "$kompiledDir"/sort_STDIN.txt)" = "String" ]; then
    if $io; then
      stdinText=
    else
      unescaped=$(</dev/stdin)
      stdinText=$(awk 'BEGIN {for(n=0;n<256;n++)ord[sprintf("%c",n)]=n} {text = text $0 ORS} END {split(text, chars, ""); for (i=1; i<=length(text); i++) { if (chars[i] == "\"") { printf("%s", "\\\"") } else if (chars[i] == "\\") { printf("%s", "\\\\") } else if (chars[i] == "\n") { printf("%s", "\\n") } else if (chars[i] == "\t") { printf("%s", "\\t") } else if (chars[i] == "\r") { printf("%s", "\\r") } else if (chars[i] == "\f") { printf("%s", "\\f") } else if (ord[chars[i]] >= 32 && ord[chars[i]] < 127) { printf("%s", chars[i]) } else { printf("\\x%02x", ord[chars[i]]) } } }' <<< "$unescaped")
      tempFile="$(mktemp tmp.stdin.XXXXXXXXXX)"
      tempFiles+=("$tempFile")
      printf '\dv{SortString{}}(\"%s\")\n' "$stdinText" > "$tempFile"
    fi
    configVars="$configVars -c STDIN $tempFile String korefile"
  fi
  execute llvm-krun $configVars -d "$kompiledDir" $flags --dry-run -o "$input_file"
fi

if [ -f "$kompiledDir/interpreter" ]; then
  execute $cmdprefix "$kompiledDir/interpreter" "$input_file" "${depth:--1}" "$kore_output"
  result=$?
else
  error 'Does not yet support Haskell backend.'
fi

case "$outputMode" in
  pretty)
    execute kprint "$kompiledDir" "$kore_output" $color > "$outputFile"
    ;;
  kore)
    cat "$kore_output" > "$outputFile"
    echo >> "$outputFile"
    ;;
  none)
    ;;
  *)
    execute kast -i kore -o "$outputMode" "$kore_output" > "$outputFile"
    ;;
esac

exit $result
